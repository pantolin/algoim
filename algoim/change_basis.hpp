#ifndef ALGOIM_CHANGE_BASIS_H
#define ALGOIM_CHANGE_BASIS_H

#include "real.hpp"
#include "uvector.hpp"
#include "bernstein.hpp"
#include "utility.hpp"

#include <numeric>
#include <vector>
#include <map>

namespace algoim::change_basis
{

namespace detail
{
    /**
     * @brief Inverts a matrix in-place using Gaussian elimination.
     * 
     * @param _matrix Square matrix to invert.
     * @param _n Number of rows (and columns) of the matrix.
     * @return True if the matrix was successfully inverted, false
     * otherwise (the matrix was singular).
     * 
     * @note This function was generated by ChatGPT, use it with care.
     */
    static bool invertMatrix(std::vector<real> &_matrix, const int _n)
    {
        assert(static_cast<int>(_matrix.size()) == (_n * _n));

        std::vector<real> augmented(_n * _n * 2, 0.0);

        // Create an augmented matrix [A | I]
        for (int i = 0; i < _n; ++i) {
            augmented[i * (2 * _n) + i + _n] = 1.0;
            for (int j = 0; j < _n; ++j) {
                augmented[i * (2 * _n) + j] = _matrix[i * _n + j];
            }
        }

        constexpr real pivot_tol = std::numeric_limits<real>::epsilon() * 100.0;

        // Gaussian elimination
        for (int i = 0; i < _n; ++i) {
            // Find pivot
            real pivot = augmented[i * (2 * _n) + i];

            if (std::abs(pivot) < pivot_tol) {
                // std::cerr << "Matrix is singular and cannot be inverted." << std::endl;
                return false;
            }

            // Scale row i to have a 1 in the pivot position
            for (int j = 0; j < 2 * _n; ++j) {
                augmented[i * (2 * _n) + j] /= pivot;
            }

            // Eliminate other rows
            for (int k = 0; k < _n; ++k) {
                if (k != i) {
                    real factor = augmented[k * (2 * _n) + i];
                    for (int j = 0; j < 2 * _n; ++j) {
                        augmented[k * (2 * _n) + j] -= factor * augmented[i * (2 * _n) + j];
                    }
                }
            }
        }

        // Extract the inverted matrix [I | A^(-1)]
        for (int i = 0; i < _n; ++i) {
            for (int j = 0; j < _n; ++j) {
                _matrix[i * _n + j] = augmented[i * (2 * _n) + (j + _n)];
            }
        }

        return true;
    }

    /**
     * @brief Computes 1D transformation coefficients from Lagrange to Bezier basis
     *  with the given @p _order.
     * 
     * @param _order Order of the transformation to be created.
     * @param _coefs Computed coefficients.
     */
    static void computeLagrangeToBezierCoefs1D(const int _order, std::vector<real> &_coefs)
    {
        assert(0 < _order);

        _coefs.resize(_order * _order);

        auto c = _coefs.data();

        const real dx = 1.0 / real(_order - 1);
        for(int pt_id = 0; pt_id < _order; ++pt_id)
        {
            const auto x = pt_id * dx;
            bernstein::evalBernsteinBasis(x, _order, c);
            c += _order;
        }

        const auto non_singular = invertMatrix(_coefs, _order);
        assert(non_singular && "Singular matrix.");
    }

    /**
     * @brief Computes the Kronecker product of two square matrices.
     * 
     * @param _lhs Left-hand-side square matrix of the product.
     * @param _rhs Right-hand-side square matrix of the product.
     * @param _res Result of the product.
     */
    void kronProd(const std::vector<real> &_lhs, const std::vector<real> &_rhs,
                  std::vector<real> &_res)
    {
        const int nl = std::sqrt(static_cast<int>(_lhs.size()));
        const int nr = std::sqrt(static_cast<int>(_rhs.size()));

        assert (nl * nl == static_cast<int>(_lhs.size()));
        assert (nr * nr == static_cast<int>(_rhs.size()));

        _res.resize(nl * nl * nr * nr);
        auto res_it = _res.begin();

        // Kronecker product.
        for(int i = 0; i < nl; ++i)
            for(int j = 0; j < nr; ++j)
                for(int k = 0; k < nl; ++k)
                    for(int l = 0; l < nr; ++l)
                        *res_it++ = _lhs[i * nl + k] * _rhs[j * nr + l];
    }


    /**
     * @brief Computes the coefficients for the change of basis from Lagrange to Bezier.
     * Previously computed results are cached.
     * 
     * @tparam N Parametric dimension.
     * @param _order Order along each parametric direction.
     * @return Reference to the (cached) coefficients.
     */
    template<int N>
    static const std::vector<real> &getLagrangeToBezierCoefs(const uvector<int, N> &_order)
    {
        static thread_local std::map<uvector<int,N>, std::vector<real>, util::UvectorCompare<int, N>> coefs;

        if (coefs.count(_order) == 0)
        {
            auto &c = coefs[_order];
            c.resize(util::sqr(prod(_order)));

            if constexpr (N == 1)
            {
                computeLagrangeToBezierCoefs1D(_order(0), c);
            }
            else
            {
                // For the lexicographical case, this order must be changed.
                const auto &lhs = getLagrangeToBezierCoefs<1>(uvector<int,1>(_order(0)));

                const uvector<int,N-1> sub_order = remove_component(_order, 0);
                const auto &rhs = getLagrangeToBezierCoefs<N-1>(sub_order);

                kronProd(lhs, rhs, c);
            }

            return c;
        }

        return coefs.at(_order);
    }
} // namespace detail

/**
 * @brief Transform coefficients from Lagrange to Bezier.
 * 
 * @tparam T Type of the coefficients.
 * @tparam N Parametric dimension.
 * @param _order Order along the parametric directions.
 * @param _lgr_vals Original Lagrange values.
 * @param _bzr_vals Newly computed Bezier values.
 */
template<int N, typename T>
static void changeLagrangeToBezier(const uvector<int, N> &_order,
                                      const T *_lgr_vals,
                                      T *_bzr_vals)
{
    assert(1 < min(_order));

    const auto &coefs = detail::getLagrangeToBezierCoefs<N>(_order);
    auto it_c = coefs.cbegin();

    const auto n = prod(_order);
    for(int i = 0; i < n; ++i, it_c += n)
        _bzr_vals[i] = std::inner_product(_lgr_vals, _lgr_vals + n, it_c, T(0.0));
}

} // namespace algoim::change_basis


#endif // ALGOIM_CHANGE_BASIS_H